#pragma kernel Main

#include "Common.cginc"

struct Triangle
{
    float2 p[3];
    float2 zw;
    float4 color;
};

StructuredBuffer<float4> PointBuffer;

AppendStructuredBuffer<Triangle> TriangleBuffer;

CBUFFER_START(Params)
    float ScreenHeight;
    float4 Tint;
    float2 Extent;
    float4x4 Transform;
CBUFFER_END

[numthreads(128, 1, 1)]
void Main(uint id : SV_DispatchThreadID)
{
    float4 pt = PointBuffer[id];
    float4 origin = mul(Transform, float4(pt.xyz, 1));
    float4 color = UnpackColor32(asuint(pt.w)) * Tint;

    Triangle o;
    o.color = color;

    // Determine the number of slices based on the radius of the
    // point on the screen.
    float radius = Extent.y / origin.w * ScreenHeight;
    uint slices = min((radius + 1) / 5, 4) + 2;

    // Slightly enlarge quad points to compensate area reduction.
    // Hopefully this line would be complied without branch.
    float2 extent = Extent * (slices == 2 ? 1.2 : 1.0);

    float sn, cs;
    sincos(UNITY_PI / slices, sn, cs);

    o.zw = origin.zw;
    o.p[0] = origin.xy + float2(0, extent.y);
    o.p[1] = origin.xy + float2(extent * float2(-sn, cs));
    o.p[2] = origin.xy + float2(extent * float2(+sn, cs));
    TriangleBuffer.Append(o);

    UNITY_LOOP for (uint i = 2; i < slices; i++)
    {
        float sn, cs;
        sincos(UNITY_PI / slices * i, sn, cs);

        o.p[0] = o.p[1];
        o.p[1] = o.p[2];
        o.p[2] = origin.xy + float2(extent * float2(-sn, cs));
        TriangleBuffer.Append(o);

        o.p[0] = o.p[1];
        o.p[1] = o.p[2];
        o.p[2] = origin.xy + float2(extent * float2(+sn, cs));
        TriangleBuffer.Append(o);
    }

    o.p[0] = o.p[1];
    o.p[1] = o.p[2];
    o.p[2] = origin.xy + float2(0, -extent.y);
    TriangleBuffer.Append(o);
}
